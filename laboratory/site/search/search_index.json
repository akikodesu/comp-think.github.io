{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Table of Contents The laboratory part of computational thinking covers with practical exercises/examples in Python the theoretical concepts contained in the computational thinking book . Each chapter has a dedicated directory to store all its related materials (e.g., data and scripts) The chapters of this part are presented in an interactive laboratory session during the computational thinking and programming course . All the laboratory lessons were created by Ivan Heibi and edited by Arcangelo Massari . Feel free to contact Arcangelo for any information or question. Chapter Materials 1. Getting started with Python 2. Programming in Python - the basics 3. Working with lists and tuples 4. Working with unordered structures 5. Recursion and working with files 6. Data analysis on Netflix shows","title":"Home"},{"location":"#table-of-contents","text":"The laboratory part of computational thinking covers with practical exercises/examples in Python the theoretical concepts contained in the computational thinking book . Each chapter has a dedicated directory to store all its related materials (e.g., data and scripts) The chapters of this part are presented in an interactive laboratory session during the computational thinking and programming course . All the laboratory lessons were created by Ivan Heibi and edited by Arcangelo Massari . Feel free to contact Arcangelo for any information or question. Chapter Materials 1. Getting started with Python 2. Programming in Python - the basics 3. Working with lists and tuples 4. Working with unordered structures 5. Recursion and working with files 6. Data analysis on Netflix shows","title":"Table of Contents"},{"location":"chapter/01/","text":"Getting started with Python Check if Python is already installed We will use a command-line interpreter \u2013 i.e., the shell \u2013 to check if you already have the last version of Python installed on your machine (Windows, Mac, or Linux). Operating systems have different command-line applications/interfaces. Windows uses PowerShell , Mac uses Terminal , and Linux uses an application called Konsole or Terminal (respectively for the KDE Plasma and GNOME desktop environments). In computing, a shell is a user interface for accessing the services of an operating system. It can be a command-line interface (CLI) or a graphical user interface (GUI) . It enables a user to perform several operations, such as file management, installations, running processes, monitoring and configuring an OS. We will use it to install packages and as an interpreter for Python. Open the Command Line Interface (CLI) Windows Open the Windows menu Type \"powershell\" in the search bar Select Windows PowerShell from the search results macOS Open the Spotlight search box in the upper right-hand corner Type \"terminal\" in the search bar Click on Terminal or just hit return if it is the first result Alternatively, go to the directory Applications/Utility and open Terminal application. Linux (Ubuntu) Open the applications drawer Type \"terminal\" or \"konsole\" in the search bar Select the Terminal/Konsole application from the results that appear Alternatively, you can press the combination Ctrl+Alt+T to open the terminal rapidly Check the Python version Type python --version (also python -V on Windows) in the command line, then press return on your keyboard to see whether you have a default version of Python already installed. You should get no message or an error message if you do not have Python installed. macOS usually comes with Python 2.7 already installed; hence the shell will show the currently installed version. For instance: python --version Python 2.7.3 Try to type python3 --version (also python3 -V on Windows) in the command line, then press return to check whether you have Python 3 installed, and eventually the last version. Download and install Python Windows Go to the Python download page Click on the download button to get the latest version of Python Double-click on the Python installer just downloaded A dialog box like the one below should appear Click on Customize installation On the following page you should keep all the checkboxes selected, and move to the next page Now you should be in the Advanced Options page. Here you need to keep checked the default options with the addition of these two check-boxes (if not already checked): Install for all users , and Add python to environment varaibles . Make sure the Customize install location has been also updated Click on the Install button, and wait until the end of the installation Finally, go to the command line and try to type python --version (also python3 -V ) and press return to check whether you correctly installed Python. macOS Go to the Python download page Click on the download button to get the latest version of Python Double-click on the downloaded .pkg file to start the installation Follow the step-by-step guidelines Finally, go to the command line and try to type python --version (also python3 --version in case you have also Python 2) and press return to check whether you correctly installed Python Linux (Ubuntu) Open the Command Line Interface (Terminal or Console) Type sudo apt-get update Type sudo apt-get install python3.10 python3-pip Finally, go to the command line and try to type python --version (also python3 --version in case you have also Python 2) and press return to check whether you correctly installed Python. Note: in case you find troubles in the process, check the following instructions according to your specific Linux distribution Play with Python in the shell Windows, Mac, and Linux users can use the shell as a Python interpreter. The interpreter is the program you will need to run Python code and scripts. Technically, the interpreter is a layer of software that works between your program and your computer hardware to get your code running. Type python (or python3 ) in the shell. You will see in the first line which version of python is installed. If it still shows you python 2.X , type exit() and press enter on your keyboard to exit from python. Try to type python3 to access the latest version of python installed on your computer. As a rule of thumb , on Windows type python , on macOS and Linux type python3 . From now on we will always use python3 for convenience In the second line, you will see >>> . It means you accessed python in interactive mode and can now type your commands to be executed by the shell. Try to type print(\"Hello world\") and press enter. >>> print(\"Hello world\") Hello World Type exit() and press enter to exit from the python interactive mode. Install Python libraries A text file containing Python code intended to be directly executed by the user is called a script . A file containing Python code designed to be imported and used from another Python file is called a module/library . Some libraries/modules (e.g. csv and collections ) are built-ins, meaning you do not need to install them, while others, developed by the larger community, must be downloaded and installed. We can install python libraries using the pip command in the shell. pip is a package management system used to install and manage software packages written in Python. You will use it whenever you want to install a Python library. In case you also have Python 2 installed on your machine, pip is renamed in pip3 . As a rule of thumb , on Windows use pip , on macOS and Linux use pip3 . From now on we will always use pip3 for convenience Type pip --version in the shell to see which version is actually installed on your machine. Note (for Windows) : If not installed, follow the instructions here to find where and which version is installed. Install modules with pip3 We will see how to install networkx and anytree . NetworkX : a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks. To install networkx type pip3 install networkx in the shell. AnyTree : Simple, lightweight and extensible Tree data structure. To install anytree type pip3 install anytree in the shell. Note: you can also type pip3 install -U <module_name> the -U option will upgrade all packages to the latest version. Whenever you want to install a library, look for the documentation page and the official name of the package to be used in the shell. Here is the list of libraries/packages you will need to install for the hands-on classes. beautifulSoup (bs4) fuzzywuzzy requests nltk nltk.data Run python3 -m nltk.downloader all to download all corpora anytree Install the editor: Visual Studio Code Programming using the shell interpreter is convenient for small tests but impractical for developing complex applications. For this reason, special editors, called integrated development environments (IDE), are used. For Python, the most widely used IDEs are Visual Studio Code, PyCharm and Atom. We suggest using Visual Studio Code for this course. Windows Download the Visual Studio Code installer for Windows. Run the downloaded installer (VSCodeUserSetup-{version}.exe). This will only take a minute By default, VS Code is installed under C:\\users{username}\\AppData\\Local\\Programs\\Microsoft VS Code Note: .NET Framework 4.5.2 or higher is required for VS Code. If you are using Windows 7, make sure you have at least .NET Framework 4.5.2 installed. You can check your version of .NET Framework using this command, reg query \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\full\" /v version from a command prompt. Note: you can find more details at https://code.visualstudio.com/docs/setup/windows macOS Download Visual Studio Code for macOS. Open the browser's download list and locate the downloaded archive. Extract the contents of the downloaded archive. (usually with a double-click) Drag Visual Studio Code.app to the Applications folder, making it available in the macOS Launchpad. Note: you can find more details at https://code.visualstudio.com/docs/setup/mac Linux For Debian/Ubuntu based distributions, download and install the .deb package (64-bit) , either through the graphical software center if it's available, or through the command line with: sudo apt install ./<file>.deb Note: you can find more details and guidelines for other linux distributions at https://code.visualstudio.com/docs/setup/linux Create and run a Python script in Visual Studio Code Install Python extension for Visual Studio Code Open Visual Studio Code Install the Python extension for VS Code from the Visual Studio Marketplace. The Python extension is named Python and it's published by Microsoft. To open the extensions marketplace click on this icon: Note: you can find more details at https://code.visualstudio.com/docs/python/python-tutorial Create and run the first Python script Select File -> New File Select Text File You need to select the type of the file (i.e. the programming language) and save it. Click on select a language , search for \"python\" and select it. Now we can write our first script. Write the following code: print(\"Hello World !!\") Run the script by clicking on the menu arrow near the run button and selecting Run Python File in Terminal Note: by default Visual Studio Code should detect the Python interpreter automatically","title":"1. Getting started with Python"},{"location":"chapter/01/#getting-started-with-python","text":"","title":"Getting started with Python"},{"location":"chapter/01/#check-if-python-is-already-installed","text":"We will use a command-line interpreter \u2013 i.e., the shell \u2013 to check if you already have the last version of Python installed on your machine (Windows, Mac, or Linux). Operating systems have different command-line applications/interfaces. Windows uses PowerShell , Mac uses Terminal , and Linux uses an application called Konsole or Terminal (respectively for the KDE Plasma and GNOME desktop environments). In computing, a shell is a user interface for accessing the services of an operating system. It can be a command-line interface (CLI) or a graphical user interface (GUI) . It enables a user to perform several operations, such as file management, installations, running processes, monitoring and configuring an OS. We will use it to install packages and as an interpreter for Python.","title":"Check if Python is already installed"},{"location":"chapter/01/#open-the-command-line-interface-cli","text":"","title":"Open the Command Line Interface (CLI)"},{"location":"chapter/01/#check-the-python-version","text":"Type python --version (also python -V on Windows) in the command line, then press return on your keyboard to see whether you have a default version of Python already installed. You should get no message or an error message if you do not have Python installed. macOS usually comes with Python 2.7 already installed; hence the shell will show the currently installed version. For instance: python --version Python 2.7.3 Try to type python3 --version (also python3 -V on Windows) in the command line, then press return to check whether you have Python 3 installed, and eventually the last version.","title":"Check the Python version"},{"location":"chapter/01/#download-and-install-python","text":"","title":"Download and install Python"},{"location":"chapter/01/#play-with-python-in-the-shell","text":"Windows, Mac, and Linux users can use the shell as a Python interpreter. The interpreter is the program you will need to run Python code and scripts. Technically, the interpreter is a layer of software that works between your program and your computer hardware to get your code running. Type python (or python3 ) in the shell. You will see in the first line which version of python is installed. If it still shows you python 2.X , type exit() and press enter on your keyboard to exit from python. Try to type python3 to access the latest version of python installed on your computer. As a rule of thumb , on Windows type python , on macOS and Linux type python3 . From now on we will always use python3 for convenience In the second line, you will see >>> . It means you accessed python in interactive mode and can now type your commands to be executed by the shell. Try to type print(\"Hello world\") and press enter. >>> print(\"Hello world\") Hello World Type exit() and press enter to exit from the python interactive mode.","title":"Play with Python in the shell"},{"location":"chapter/01/#install-python-libraries","text":"A text file containing Python code intended to be directly executed by the user is called a script . A file containing Python code designed to be imported and used from another Python file is called a module/library . Some libraries/modules (e.g. csv and collections ) are built-ins, meaning you do not need to install them, while others, developed by the larger community, must be downloaded and installed. We can install python libraries using the pip command in the shell. pip is a package management system used to install and manage software packages written in Python. You will use it whenever you want to install a Python library. In case you also have Python 2 installed on your machine, pip is renamed in pip3 . As a rule of thumb , on Windows use pip , on macOS and Linux use pip3 . From now on we will always use pip3 for convenience Type pip --version in the shell to see which version is actually installed on your machine. Note (for Windows) : If not installed, follow the instructions here to find where and which version is installed.","title":"Install Python libraries"},{"location":"chapter/01/#install-modules-with-pip3","text":"We will see how to install networkx and anytree . NetworkX : a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks. To install networkx type pip3 install networkx in the shell. AnyTree : Simple, lightweight and extensible Tree data structure. To install anytree type pip3 install anytree in the shell. Note: you can also type pip3 install -U <module_name> the -U option will upgrade all packages to the latest version. Whenever you want to install a library, look for the documentation page and the official name of the package to be used in the shell. Here is the list of libraries/packages you will need to install for the hands-on classes. beautifulSoup (bs4) fuzzywuzzy requests nltk nltk.data Run python3 -m nltk.downloader all to download all corpora anytree","title":"Install modules with pip3"},{"location":"chapter/01/#install-the-editor-visual-studio-code","text":"Programming using the shell interpreter is convenient for small tests but impractical for developing complex applications. For this reason, special editors, called integrated development environments (IDE), are used. For Python, the most widely used IDEs are Visual Studio Code, PyCharm and Atom. We suggest using Visual Studio Code for this course.","title":"Install the editor: Visual Studio Code"},{"location":"chapter/01/#create-and-run-a-python-script-in-visual-studio-code","text":"","title":"Create and run a Python script in Visual Studio Code"},{"location":"chapter/01/#install-python-extension-for-visual-studio-code","text":"Open Visual Studio Code Install the Python extension for VS Code from the Visual Studio Marketplace. The Python extension is named Python and it's published by Microsoft. To open the extensions marketplace click on this icon: Note: you can find more details at https://code.visualstudio.com/docs/python/python-tutorial","title":"Install Python extension for Visual Studio Code"},{"location":"chapter/01/#create-and-run-the-first-python-script","text":"Select File -> New File Select Text File You need to select the type of the file (i.e. the programming language) and save it. Click on select a language , search for \"python\" and select it. Now we can write our first script. Write the following code: print(\"Hello World !!\") Run the script by clicking on the menu arrow near the run button and selecting Run Python File in Terminal Note: by default Visual Studio Code should detect the Python interpreter automatically","title":"Create and run the first Python script"},{"location":"chapter/02/","text":"Programming in Python - the basics Syntax in Python Variables Some general considerations In Python, a variable is created when you first assign a value to it planet = 'Jupiter' The name of a variable cannot start with a digit or contain a special symbol (e.g., |\u00a3$%@# ) Some keywords cannot be used for naming variables. False | class | finally | is | return | None | continue | for | lambda | try | True | def from | nonlocal | while | and | del | global | not | with | as | elif | if | or yield | assert | else | import | pass | break | except | in | raise Python is case-sensitive: planet and Planet are different variables Naming conventions The following naming styles are commonly distinguished: snake case: lower_case_with_underscores CamelCase: CapitalizedWords mixedCase: differs from CamelCase by initial lowercase character Python naming convention The Python Enhancement Proposal number 8 (PEP 8) states: Function names should be lowercase, with words separated by underscores as necessary to improve readability. Variable names follow the same convention as function names. Use names that make sense: planet = 'Jupiter' rather than p = 'Jupiter' Punctuation and indentation You don't need to add punctuation at the end of lines planet = 'Jupiter' position_from_sun = 5 Use semicolons in case you want to put multiple statements in a single line planet = 'Jupiter' ; position_from_sun = 5 Document your code using comments # this is the first comment planet = 'Jupiter' # and this is the second comment # ... and now a third! text = \"# This is not a comment because it's inside quotes.\" Data types Numbers # Integers known_satellites = 80 # Floating point numbers hydrogen_percentage = 0.89 The int() and float() methods convert booleans, numbers and number-like strings to integers and floating point numbers known_satellites = int('80') # 80 the_world_is_flat = float(True) # 1.0 the_world_is_flat = float(False) # 0.0 Strings planet = 'Jupiter' # This is a string The str() method returns the string representation of a given object known_satellites = str(80) # Use the type() function to return the type of the object print(type(known_satellites)) # <class 'str'> Lists # You can initialise an empty list with the list() method planets = list() # Or using square brackets planets = [] # To fill the list, you can put the items separated by commas between square brackets planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'] # In Python you count from zero print(planets[4]) # Jupiter # To sort the list planets_sorted_alphabetically = sorted(planets) # planets = ['Earth', 'Jupiter', 'Mars', 'Mercury', 'Saturn', 'Uranus', 'Venus'] # Add a new item to the list planets.append('Neptune') # planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] # Count how many elements we have in a list planets_count = len(planets) # 8 String interpolation String interpolation is the process of substituting values of variables into placeholders in a string print(\"The fifth planet is %s\" %(planets[4])) print(\"The fifth planet is {}\".format(planets[4])) print(f\"The fifth planet is {planets[4]}\") # The fifth planet is Jupiter Operators Arithmetic operators x = 5 y = 2 # + Add two operands print(x + y) # 7 # - Subtract the right operand from the left one print(x - y) # 3 # * Multiply two operands print(x * y) # 10 # / Divide the left operand by the right one. Division always returns a floating point number print(x / y) # 2.5 # ** Raise the left operand to the power of the right one print(x ** y) # 25 # % Return the remainder of the division. It is called modulus print(x % y) # 1 # // Discard the fractional part of the division's result. It is called floor division print(x // y) # 2 Comparison operators x = 5 y = 2 # > Greater than - True if the left operand is greater than the right one print(x > y) # True # < Less than - True if the left operand is less than the right one print(x < y) # False # == Equal to - True if both operands are equal print(x == y) # False # != Not equal to - True if operands are not equal print(x != y) # True # >= Greater than or equal to - True if the left operand is greater than or equal to the right one print(x >= y) # True # <= Less than or equal to - True if the left operand is less than or equal to the right one print(x <= y) # False Note the difference : = is an assignment operator, used to assign a value to a variable. Conversely, == is a Boolean operator that checks whether the right operand is equal to the left one Logic operators x = True y = False # \"and\": True if both the operands are true print(x and y) # False # \"or\": True if at least one of the operands is true print(x or y) # True # \"not\": True if the operand is False and viceversa print(not x) # False Assignment operators # with \"=\" x = 5 print(x) # with \"+=\" x += 5 # A shortcut for x = x + 5 print(x) # with \"-=\" x -= 2 # A shortcut for x = x - 2 print(x) # Try with other arithmetic operands ... Membership operators planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'] # \"in\": True if value/variable is found in the sequence print('Pluto' in planets) # False # \"not in\": True if value/variable is not found in the sequence print('Moon' not in planets) # True Conditional statement A decision might be taken only when a specific condition is satisfied the_world_is_flat = True if the_world_is_flat: print(\"Be careful not to fall off!\") Use indentation to separate code blocks by pressing the key. A block is a piece of Python program text that is executed as a unit, i.e., a conditional statement or a function body Functions A block of code which defines a specific algorithm and runs only when it is called # def {func_name}({parameter_1}, {parameter_2}, ...): # {func_body} def add(num1, num2): return num1 + num2 my_sum = add(5,4) print(my_sum) # 9 Exercises 1st Exercise The function is_friend_of_harry() returns a True value if a given name (i.e. type string) is one of the friends of Harry Potter, otherwise the function returns False . Let's pretend the friends of Harry Potter are: \"Ron\", \"Hermione\", \"Hagrid\", and \"Dumbledore\" . Example: calling the function is_friend_of_harry(\"Malfoy\") returns False . 1.a) Define the function is_friend_of_harry() , and call it for each one of the following characters: \"Hagrid\", \"Voldemort\", and \"Bellatrix\" . Print the result (i.e. True/False ) of each call. Show solution def is_friend_of_harry(name): friends_list = [\"Ron\", \"Hermione\", \"Hagrid\", \"Dumbledore\"] if name in friends_list: return True else: return False print(is_friend_of_harry(\"Hagrid\")) print(is_friend_of_harry(\"Voldemort\")) print(is_friend_of_harry(\"Bellatrix\")) 1.b) Write a portion of code that prints \"Harry has friends!\" if at least one of the previous characters is a friend of Harry, otherwise, print \"Harry has no friends!\" . Show solution is_hagrid_friend = is_friend_of_harry(\"Hagrid\") is_voldemort_friend = is_friend_of_harry(\"Voldemort\") is_bellatrix_friend = is_friend_of_harry(\"Bellatrix\") if is_hagrid_friend or is_voldemort_friend or is_bellatrix_friend: print(\"Harry has friends!\") else: print(\"Harry has no friends!!\") 1.c) Let's make our function is_friend_of_harry() a bit more powerful. The new function should work the same way even if the given name is not well written, such that it should handle these cases: a) The letters of the name are written in different formats: uppercase and lowercase (e.g. \"ron\", \"RON\", \"Ron\", \"roN\") b) The name includes spaces (e.g. \"Ron \", \" Ron\") c) The name has both (a) and (b) cases combined in it (e.g. \" roN\") Hint: in python {string}.lower() transforms a string to its lowercase form; {string}.strip() removes the starting and ending whitespaces (if any); and {string}.capitalize() capitalizes the first letter of a string Show solution def is_friend_of_harry(name): friends_list = [\"Ron\", \"Hermione\", \"Hagrid\", \"Dumbledore\"] name = name.lower() name = name.strip() name = name.capitalize() if name in friends_list: return True else: return False 1.d) Define another function is_prof_friend_of_harry() which returns a True value if a given name, which might be written in any format described (1.c), is a professor and a friend of Harry, otherwise the function must return False . The function should call the improved version of the function is_friend_of_harry() in its code (i.e. defined in (1.c)). Let's pretend the professors of Harry Potter are: \"Snape\", \"Umbridge\", and \"Hagrid\" . Show solution def is_prof_friend_of_harry(name): prof_list = [\"Snape\", \"Umbridge\", \"Hagrid\"] name = name.lower() name = name.strip() name = name.capitalize() if name in prof_list and is_friend_of_harry(name): return True else: return False print(is_prof_friend_of_harry(\"snape\")) print(is_prof_friend_of_harry(\" umbridge \")) print(is_prof_friend_of_harry(\" hagrid\")) 2nd Exercise Each house of Hogwarts has a score which is updated with the addition or subtraction of points based on the behaviour of the houses' members, e.g. after a rule violation. We have two lists: the houses of Hogwarts houses = [\"Gryffindor\", \"Hufflepuff\", \"Ravenclaw\", \"Slytherin\"] the score of each house scores = [0,0,0,0] . The score of a house in position n in houses is placed in the same position n in scores . 2.a) Define the function update_house_score() which increments/decrements the score of a specific house with a given value of points. The function takes three parameters: house_name , action , and points . The value of action is a string which is either \"+\" (points will be added) or \"-\" (points will be subtracted) Example: Calling the function this way: update_house_score(\"Gryffindor\", \"+\", 5) should increment the score of house Gryffindor by 5 points. Hint: The function {list}.index({value}) returns the index of an element in the list, e.g. houses.index(\"Hufflepuff\") returns the value 1 Show solution houses = [\"Gryffindor\", \"Hufflepuff\", \"Ravenclaw\", \"Slytherin\"] scores = [0,0,0,0] def update_house_score(house_name, action, points): house_index = houses.index(house_name) if action == \"+\": scores[house_index] += points else: scores[house_index] -= points 2.b) After the Quidditch cup the Houses have increased/decreased their scores: +10 Gryffindor, +7 Hufflepuff, -3 Slytherin. After the end of the game a member of house \"Slytherin\" helped a man riding his broom, so his house gained back 5 points. Call the function update_house_score() for each action in order to update the houses points and print the two lists: houses and scores . Show solution update_house_score(\"Gryffindor\", \"+\", 10) update_house_score(\"Hufflepuff\", \"+\", 7) update_house_score(\"Slytherin\", \"-\", 3) update_house_score(\"Slytherin\", \"+\", 5) print(houses) print(scores) 2.c) redefine update_house_score() using the function eval() ( https://docs.python.org/3/library/functions.html#eval ) Show solution def update_house_score(house_name, action, points): house_index = houses.index(house_name) scores[house_index] = eval(str(points) + action + str(scores[house_index])) return scores","title":"2. Programming in Python - the basics"},{"location":"chapter/02/#programming-in-python-the-basics","text":"","title":"Programming in Python - the basics"},{"location":"chapter/02/#syntax-in-python","text":"","title":"Syntax in Python"},{"location":"chapter/02/#variables","text":"Some general considerations In Python, a variable is created when you first assign a value to it planet = 'Jupiter' The name of a variable cannot start with a digit or contain a special symbol (e.g., |\u00a3$%@# ) Some keywords cannot be used for naming variables. False | class | finally | is | return | None | continue | for | lambda | try | True | def from | nonlocal | while | and | del | global | not | with | as | elif | if | or yield | assert | else | import | pass | break | except | in | raise Python is case-sensitive: planet and Planet are different variables Naming conventions The following naming styles are commonly distinguished: snake case: lower_case_with_underscores CamelCase: CapitalizedWords mixedCase: differs from CamelCase by initial lowercase character Python naming convention The Python Enhancement Proposal number 8 (PEP 8) states: Function names should be lowercase, with words separated by underscores as necessary to improve readability. Variable names follow the same convention as function names. Use names that make sense: planet = 'Jupiter' rather than p = 'Jupiter'","title":"Variables"},{"location":"chapter/02/#punctuation-and-indentation","text":"You don't need to add punctuation at the end of lines planet = 'Jupiter' position_from_sun = 5 Use semicolons in case you want to put multiple statements in a single line planet = 'Jupiter' ; position_from_sun = 5 Document your code using comments # this is the first comment planet = 'Jupiter' # and this is the second comment # ... and now a third! text = \"# This is not a comment because it's inside quotes.\"","title":"Punctuation and indentation"},{"location":"chapter/02/#data-types","text":"","title":"Data types"},{"location":"chapter/02/#string-interpolation","text":"String interpolation is the process of substituting values of variables into placeholders in a string print(\"The fifth planet is %s\" %(planets[4])) print(\"The fifth planet is {}\".format(planets[4])) print(f\"The fifth planet is {planets[4]}\") # The fifth planet is Jupiter","title":"String interpolation"},{"location":"chapter/02/#operators","text":"","title":"Operators"},{"location":"chapter/02/#conditional-statement","text":"A decision might be taken only when a specific condition is satisfied the_world_is_flat = True if the_world_is_flat: print(\"Be careful not to fall off!\") Use indentation to separate code blocks by pressing the key. A block is a piece of Python program text that is executed as a unit, i.e., a conditional statement or a function body","title":"Conditional statement"},{"location":"chapter/02/#functions","text":"A block of code which defines a specific algorithm and runs only when it is called # def {func_name}({parameter_1}, {parameter_2}, ...): # {func_body} def add(num1, num2): return num1 + num2 my_sum = add(5,4) print(my_sum) # 9","title":"Functions"},{"location":"chapter/02/#exercises","text":"","title":"Exercises"},{"location":"chapter/02/#1st-exercise","text":"The function is_friend_of_harry() returns a True value if a given name (i.e. type string) is one of the friends of Harry Potter, otherwise the function returns False . Let's pretend the friends of Harry Potter are: \"Ron\", \"Hermione\", \"Hagrid\", and \"Dumbledore\" . Example: calling the function is_friend_of_harry(\"Malfoy\") returns False . 1.a) Define the function is_friend_of_harry() , and call it for each one of the following characters: \"Hagrid\", \"Voldemort\", and \"Bellatrix\" . Print the result (i.e. True/False ) of each call. Show solution def is_friend_of_harry(name): friends_list = [\"Ron\", \"Hermione\", \"Hagrid\", \"Dumbledore\"] if name in friends_list: return True else: return False print(is_friend_of_harry(\"Hagrid\")) print(is_friend_of_harry(\"Voldemort\")) print(is_friend_of_harry(\"Bellatrix\")) 1.b) Write a portion of code that prints \"Harry has friends!\" if at least one of the previous characters is a friend of Harry, otherwise, print \"Harry has no friends!\" . Show solution is_hagrid_friend = is_friend_of_harry(\"Hagrid\") is_voldemort_friend = is_friend_of_harry(\"Voldemort\") is_bellatrix_friend = is_friend_of_harry(\"Bellatrix\") if is_hagrid_friend or is_voldemort_friend or is_bellatrix_friend: print(\"Harry has friends!\") else: print(\"Harry has no friends!!\") 1.c) Let's make our function is_friend_of_harry() a bit more powerful. The new function should work the same way even if the given name is not well written, such that it should handle these cases: a) The letters of the name are written in different formats: uppercase and lowercase (e.g. \"ron\", \"RON\", \"Ron\", \"roN\") b) The name includes spaces (e.g. \"Ron \", \" Ron\") c) The name has both (a) and (b) cases combined in it (e.g. \" roN\") Hint: in python {string}.lower() transforms a string to its lowercase form; {string}.strip() removes the starting and ending whitespaces (if any); and {string}.capitalize() capitalizes the first letter of a string Show solution def is_friend_of_harry(name): friends_list = [\"Ron\", \"Hermione\", \"Hagrid\", \"Dumbledore\"] name = name.lower() name = name.strip() name = name.capitalize() if name in friends_list: return True else: return False 1.d) Define another function is_prof_friend_of_harry() which returns a True value if a given name, which might be written in any format described (1.c), is a professor and a friend of Harry, otherwise the function must return False . The function should call the improved version of the function is_friend_of_harry() in its code (i.e. defined in (1.c)). Let's pretend the professors of Harry Potter are: \"Snape\", \"Umbridge\", and \"Hagrid\" . Show solution def is_prof_friend_of_harry(name): prof_list = [\"Snape\", \"Umbridge\", \"Hagrid\"] name = name.lower() name = name.strip() name = name.capitalize() if name in prof_list and is_friend_of_harry(name): return True else: return False print(is_prof_friend_of_harry(\"snape\")) print(is_prof_friend_of_harry(\" umbridge \")) print(is_prof_friend_of_harry(\" hagrid\"))","title":"1st Exercise"},{"location":"chapter/02/#2nd-exercise","text":"Each house of Hogwarts has a score which is updated with the addition or subtraction of points based on the behaviour of the houses' members, e.g. after a rule violation. We have two lists: the houses of Hogwarts houses = [\"Gryffindor\", \"Hufflepuff\", \"Ravenclaw\", \"Slytherin\"] the score of each house scores = [0,0,0,0] . The score of a house in position n in houses is placed in the same position n in scores . 2.a) Define the function update_house_score() which increments/decrements the score of a specific house with a given value of points. The function takes three parameters: house_name , action , and points . The value of action is a string which is either \"+\" (points will be added) or \"-\" (points will be subtracted) Example: Calling the function this way: update_house_score(\"Gryffindor\", \"+\", 5) should increment the score of house Gryffindor by 5 points. Hint: The function {list}.index({value}) returns the index of an element in the list, e.g. houses.index(\"Hufflepuff\") returns the value 1 Show solution houses = [\"Gryffindor\", \"Hufflepuff\", \"Ravenclaw\", \"Slytherin\"] scores = [0,0,0,0] def update_house_score(house_name, action, points): house_index = houses.index(house_name) if action == \"+\": scores[house_index] += points else: scores[house_index] -= points 2.b) After the Quidditch cup the Houses have increased/decreased their scores: +10 Gryffindor, +7 Hufflepuff, -3 Slytherin. After the end of the game a member of house \"Slytherin\" helped a man riding his broom, so his house gained back 5 points. Call the function update_house_score() for each action in order to update the houses points and print the two lists: houses and scores . Show solution update_house_score(\"Gryffindor\", \"+\", 10) update_house_score(\"Hufflepuff\", \"+\", 7) update_house_score(\"Slytherin\", \"-\", 3) update_house_score(\"Slytherin\", \"+\", 5) print(houses) print(scores) 2.c) redefine update_house_score() using the function eval() ( https://docs.python.org/3/library/functions.html#eval ) Show solution def update_house_score(house_name, action, points): house_index = houses.index(house_name) scores[house_index] = eval(str(points) + action + str(scores[house_index])) return scores","title":"2nd Exercise"},{"location":"chapter/03/","text":"Working with lists and tuples Tuples Similar to lists, but their values can\u2019t be modified numbers = (10, 30, 50, 70) print(numbers[2]) # TypeError: 'tuple' object does not support item assignment numbers[2] = 55 A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: empty = () singleton = 'hello', # <-- note trailing comma len(empty) # 0 len(singleton) # ('hello',) The \"for\" statement Python's for statement iterates over the items of any sequence (e.g., strings, lists, tuples), in the order that they appear in the sequence. # What is the thickness of a sheet of paper folded 10 times? times = [1,2,3,4,5,6,7,8,9,10] thickness = 0.1 for i in times: thickness *= 2 print(thickness) # 102.4 If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions. # What is the thickness of a sheet of paper folded 39 times? thickness = 0.1 for i in range(39): thickness *= 2 print(thickness) # 54975581388.8 cm = 549755.813888 Km # Which is more than the distance between the Earth and the Moon (384400 Km) The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a different increment (even negative; sometimes this is called the 'step'): list(range(5, 10)) # [5, 6, 7, 8, 9] list(range(0, 10, 3)) # [0, 3, 6, 9] list(range(-10, -100, -30)) # [-10, -40, -70] The \"while\" statement The while statement is used for repeated execution as long as an expression is true. We generally use this loop when we don't know the number of times to iterate beforehand. distance_earth_moon = 38440000000 thickness = 0.1 times = 0 while thickness < distance_earth_moon: thickness *= 2 times += 1 print(times) # 39 Make sure that the while loop condition becomes false at some point, otherwise, the loop will continue forever (or until the PC crashes or the laptop battery runs out) Exercises 1st Exercise Let's pretend we have a list containing the titles of all the Computational Thinking lessons. The list is ordered following the established schedule. Below is the list: ctp_lessons = [\"Introduction to the course\",\"Introduction to Computational Thinking\",\"Algorithms\",\"Laboratory\",\"Computability\",\"Programming languages\",\"Organising information: ordered structures\",\"Laboratory\",\"Brute-force algorithms\",\"Laboratory\",\"Organising information: unordered structures\",\"Laboratory\",\"Recursion\",\"Laboratory\",\"Divide and conquer algorithms\",\"Laboratory\",\"Dynamic programming algorithms\",\"Organising information: trees\",\"Backtracking algorithms\",\"Organising information: graphs\",\"Greedy algorithms\"] 1.a) Define a function named lab_lessons() which takes ctp_lessons as a parameter and returns the total number of \"Laboratory\" lessons. Show solution def lab_lessons(a_list): count = 0 for title in a_list: if title == \"Laboratory\": count += 1 return count 1.b) Define a function named all_before_lab() which takes ctp_lessons as a parameter and returns a list containing all the lessons scheduled before the first \"Laboratory\" lesson. Show solution def all_before_lab(a_list): result = [] i = 0 title = a_list[i] while title != \"Laboratory\": result.append(title) i += 1 title = a_list[i] return result 1.c) Let's pretend we have a new list representing an extended version of the ctp_lessons , such that it embeds information about the date, time and the duration (in hours) of the each lesson. We call the new list ctp_lessons_extended . Each element is represented as a tuple: ([HOURS],[DATE],[TIME],[TITLE]) . For instance, the third lesson \"Algorithms\" will have the corresponding tuple: (2,\"15/10/21\",\"12:30-14:30\",\"Algorithms\") . Here we have the entire ctp_lessons_extended : ctp_lessons_extended = [(2,\"12/10/22\",\"09:30-11:30\",\"Introduction to the course\"),(2,\"14/10/22\",\"12:30-14:30 \",\"Introduction to Computational Thinking\"),(2,\"17/10/22\",\"09:30-11:30\",\"Algorithms\"),(2,\"19/10/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"21/10/22\",\"12:30-14:30\",\"Computability\"),(2,\"24/10/22\",\"09:30-11:30\",\"Programming languages\"),(2,\"26/10/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"28/10/22\",\"12:30-14:30\",\"Organising information: ordered structures\"),(2,\"09/11/22\",\"09:30-11:30\",\"Brute-force algorithms\"),(2,\"11/11/22\",\"12:30-14:30\",\"Laboratory\"),(2,\"14/11/22\",\"09:30-11:30\",\"Organising information: unordered structures\"),(2,\"16/11/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"21/11/22\",\"09:30-11:30\",\"Recursion\"),(2,\"23/11/22\",\"09:30-11:30\",\"Divide and conquer algorithms\"),(2,\"28/11/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"30/11/22\",\"09:30-11:30\",\"Dynamic programming algorithms\"),(2,\"05/12/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"12/12/22\",\"09:30-11:30\",\"Organising information: trees\"),(2,\"14/12/22\",\"09:30-11:30\",\"Backtracking algorithms\"),(2,\"19/12/22\",\"09:30-11:30\",\"Organising information: graphs\"),(2,\"21/12/22\",\"09:30-11:30\",\"Greedy algorithms\")] Define a function max_lessons_hours() which takes ctp_lessons_extended and a number max_hours as parameters, and returns a list containing only the titles of all the lessons which could be attended with a maximum number of hours = max_hours , starting from the first lesson of the year. Show solution def max_lessons_hours(a_list, max_hours): result = [] tot_hours = 0 i = 0 while tot_hours < max_hours: title = a_list[i][3] result.append(title) tot_hours += a_list[i][0] i += 1 return result 1.d) One of the students attending the course, Tim Berners Lee, thinks he knows enough about the materials taught in the course, so he will take a break and go on a vacation on 11/11/22 for two weeks. Right after that, when he returns, he will attend the lectures again, starting from the first available one according to the schedule until the end of the course. Write down a portion of the code that prints the titles of the lectures that Tim Berners Lee will attend at the end of the course. Hint: take a look at the datetime library Show solution from datetime import datetime vacation_date = datetime.strptime(\"11/11/22\", '%d/%m/%y') back_date = vacation_date + datetime.timedelta(weeks=2) result = [] i = 0 for lesson_tuple in ctp_lessons_extended: lesson_date = datetime.datetime.strptime(lesson_tuple[1], '%d/%m/%y') if lesson_date < vacation_date or lesson_date > back_date: result.append(lesson_tuple[3]) print(result)","title":"3. Working with lists and tuples"},{"location":"chapter/03/#working-with-lists-and-tuples","text":"","title":"Working with lists and tuples"},{"location":"chapter/03/#tuples","text":"Similar to lists, but their values can\u2019t be modified numbers = (10, 30, 50, 70) print(numbers[2]) # TypeError: 'tuple' object does not support item assignment numbers[2] = 55 A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: empty = () singleton = 'hello', # <-- note trailing comma len(empty) # 0 len(singleton) # ('hello',)","title":"Tuples"},{"location":"chapter/03/#the-for-statement","text":"Python's for statement iterates over the items of any sequence (e.g., strings, lists, tuples), in the order that they appear in the sequence. # What is the thickness of a sheet of paper folded 10 times? times = [1,2,3,4,5,6,7,8,9,10] thickness = 0.1 for i in times: thickness *= 2 print(thickness) # 102.4 If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions. # What is the thickness of a sheet of paper folded 39 times? thickness = 0.1 for i in range(39): thickness *= 2 print(thickness) # 54975581388.8 cm = 549755.813888 Km # Which is more than the distance between the Earth and the Moon (384400 Km) The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a different increment (even negative; sometimes this is called the 'step'): list(range(5, 10)) # [5, 6, 7, 8, 9] list(range(0, 10, 3)) # [0, 3, 6, 9] list(range(-10, -100, -30)) # [-10, -40, -70]","title":"The \"for\" statement"},{"location":"chapter/03/#the-while-statement","text":"The while statement is used for repeated execution as long as an expression is true. We generally use this loop when we don't know the number of times to iterate beforehand. distance_earth_moon = 38440000000 thickness = 0.1 times = 0 while thickness < distance_earth_moon: thickness *= 2 times += 1 print(times) # 39 Make sure that the while loop condition becomes false at some point, otherwise, the loop will continue forever (or until the PC crashes or the laptop battery runs out)","title":"The \"while\" statement"},{"location":"chapter/03/#exercises","text":"","title":"Exercises"},{"location":"chapter/03/#1st-exercise","text":"Let's pretend we have a list containing the titles of all the Computational Thinking lessons. The list is ordered following the established schedule. Below is the list: ctp_lessons = [\"Introduction to the course\",\"Introduction to Computational Thinking\",\"Algorithms\",\"Laboratory\",\"Computability\",\"Programming languages\",\"Organising information: ordered structures\",\"Laboratory\",\"Brute-force algorithms\",\"Laboratory\",\"Organising information: unordered structures\",\"Laboratory\",\"Recursion\",\"Laboratory\",\"Divide and conquer algorithms\",\"Laboratory\",\"Dynamic programming algorithms\",\"Organising information: trees\",\"Backtracking algorithms\",\"Organising information: graphs\",\"Greedy algorithms\"] 1.a) Define a function named lab_lessons() which takes ctp_lessons as a parameter and returns the total number of \"Laboratory\" lessons. Show solution def lab_lessons(a_list): count = 0 for title in a_list: if title == \"Laboratory\": count += 1 return count 1.b) Define a function named all_before_lab() which takes ctp_lessons as a parameter and returns a list containing all the lessons scheduled before the first \"Laboratory\" lesson. Show solution def all_before_lab(a_list): result = [] i = 0 title = a_list[i] while title != \"Laboratory\": result.append(title) i += 1 title = a_list[i] return result 1.c) Let's pretend we have a new list representing an extended version of the ctp_lessons , such that it embeds information about the date, time and the duration (in hours) of the each lesson. We call the new list ctp_lessons_extended . Each element is represented as a tuple: ([HOURS],[DATE],[TIME],[TITLE]) . For instance, the third lesson \"Algorithms\" will have the corresponding tuple: (2,\"15/10/21\",\"12:30-14:30\",\"Algorithms\") . Here we have the entire ctp_lessons_extended : ctp_lessons_extended = [(2,\"12/10/22\",\"09:30-11:30\",\"Introduction to the course\"),(2,\"14/10/22\",\"12:30-14:30 \",\"Introduction to Computational Thinking\"),(2,\"17/10/22\",\"09:30-11:30\",\"Algorithms\"),(2,\"19/10/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"21/10/22\",\"12:30-14:30\",\"Computability\"),(2,\"24/10/22\",\"09:30-11:30\",\"Programming languages\"),(2,\"26/10/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"28/10/22\",\"12:30-14:30\",\"Organising information: ordered structures\"),(2,\"09/11/22\",\"09:30-11:30\",\"Brute-force algorithms\"),(2,\"11/11/22\",\"12:30-14:30\",\"Laboratory\"),(2,\"14/11/22\",\"09:30-11:30\",\"Organising information: unordered structures\"),(2,\"16/11/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"21/11/22\",\"09:30-11:30\",\"Recursion\"),(2,\"23/11/22\",\"09:30-11:30\",\"Divide and conquer algorithms\"),(2,\"28/11/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"30/11/22\",\"09:30-11:30\",\"Dynamic programming algorithms\"),(2,\"05/12/22\",\"09:30-11:30\",\"Laboratory\"),(2,\"12/12/22\",\"09:30-11:30\",\"Organising information: trees\"),(2,\"14/12/22\",\"09:30-11:30\",\"Backtracking algorithms\"),(2,\"19/12/22\",\"09:30-11:30\",\"Organising information: graphs\"),(2,\"21/12/22\",\"09:30-11:30\",\"Greedy algorithms\")] Define a function max_lessons_hours() which takes ctp_lessons_extended and a number max_hours as parameters, and returns a list containing only the titles of all the lessons which could be attended with a maximum number of hours = max_hours , starting from the first lesson of the year. Show solution def max_lessons_hours(a_list, max_hours): result = [] tot_hours = 0 i = 0 while tot_hours < max_hours: title = a_list[i][3] result.append(title) tot_hours += a_list[i][0] i += 1 return result 1.d) One of the students attending the course, Tim Berners Lee, thinks he knows enough about the materials taught in the course, so he will take a break and go on a vacation on 11/11/22 for two weeks. Right after that, when he returns, he will attend the lectures again, starting from the first available one according to the schedule until the end of the course. Write down a portion of the code that prints the titles of the lectures that Tim Berners Lee will attend at the end of the course. Hint: take a look at the datetime library Show solution from datetime import datetime vacation_date = datetime.strptime(\"11/11/22\", '%d/%m/%y') back_date = vacation_date + datetime.timedelta(weeks=2) result = [] i = 0 for lesson_tuple in ctp_lessons_extended: lesson_date = datetime.datetime.strptime(lesson_tuple[1], '%d/%m/%y') if lesson_date < vacation_date or lesson_date > back_date: result.append(lesson_tuple[3]) print(result)","title":"1st Exercise"},{"location":"chapter/04/","text":"Working with unordered structures Sets A collection of unordered and unindexed items We use Sets in order to have a collection without duplicates The items of a set can't be accessed by referring to an index or a key A Set contains only immutable data types, e.g. strings, numbers, or tuples # create a set of string items a_set = {\"Roma\", \"Torino\", \"Bologna\"} # create a set from a list a_set = set([\"Roma\", \"Torino\", \"Bologna\",\"Roma\"]) # add an item to the set a_set.add(\"Palermo\") # remove an item from the set a_set.remove(\"Palermo\") # raise an error if the item isn't found a_set.discard(\"Palermo\") # doesn't raise errors if the item isn't found #ERROR: we can't add a mutable item to the set a_set.add([\"Rimini\",\"Firenze\"]) # some operations: union, intersection, difference ... etc b_set = {\"Napoli\", \"Bari\", \"Lecce\", \"Roma\"} new_set = a_set.union(b_set) #OUTPUT: {'Bari', 'Bologna', 'Lecce', 'Napoli', 'Roma', 'Torino'} new_set = a_set.intersection(b_set) #OUTPUT: {'Roma'} new_set = a_set.difference(b_set) #OUTPUT: {'Bologna', 'Torino'} Dictionaries A data structure that can store data in the form of key-value pairs It provides an efficient and useful way for organizing the data under specific typologies (keys) The items of a dictionary are accessed by specifying a key The key values should be immutable data types, e.g. strings, numbers, or tuples A dictionary can't contain duplicate keys # create a dictionary ages_dict = {} # add a new (key,value) pair ages_dict[\"Marco\"] = 25 ages_dict[\"Alessia\"] = 22 ages_dict[\"Giulia\"] = 21 #OUTPUT: {'Marco': 25, 'Alessia':22, 'Giulia':21} # accessing an item print(ages_dict[\"Marco\"]) # remove an item from the dictionary del ages_dict[\"Marco\"] # important methods ages_dict.items() #returns a sequence of (key,value) pairs #OUTPUT: [('Alessia',22),('Giulia',21)] a_dict = {\"Pippo\":34} ages_dict.update(a_dict) #updates ages_dict with the (key,value) pairs of a_dict #OUTPUT: {'Alessia': 22, 'Giulia':21, 'Pippo':34} Exercises 1st Exercise The variable lyrics contains the lyrics (string value) of the song \"Lonely Boy\" by \"The Black Keys\". The words are all written in lowercase and the line breaks are represented with ;; lyrics = \"well i\u2019m so above you ;; and it\u2019s plain to see ;; but i came to love you anyway ;; so you pulled my heart out ;; and i don\u2019t mind bleeding ;; any old time you keep me waiting ;; waiting, waiting ;; oh, oh-oh i got a love that keeps me waiting ;; oh, oh-oh i got a love that keeps me waiting ;; i\u2019m a lonely boy ;; i\u2019m a lonely boy ;; oh, oh-oh i got a love that keeps me waiting ;; well your mama kept you but your daddy left you ;; and i should\u2019ve done you just the same ;; but i came to love you ;; am i born to bleed? ;; any old time you keep me waiting ;; waiting, waiting ;; oh, oh-oh i got a love that keeps me waiting ;; oh, oh-oh i got a love that keeps me waiting ;; i\u2019m a lonely boy ;; i\u2019m a lonely boy ;; oh, oh-oh i got a love that keeps me waiting ;; hey! ;; oh, oh-oh i got a love that keeps me waiting ;; oh, oh-oh i got a love that keeps me waiting ;; i\u2019m a lonely boy ;; i\u2019m a lonely boy ;; oh, oh-oh i got a love that keeps me waiting\" 1.a) Define the function clean_lyrics() which takes lyrics as parameter and returns a set of all the unique words of the song excluding the following words ['a', 'i', 'am', 'to', ';;', 'the', 'you', 'don\u2019t', 'and', 'that', 'i\u2019m', 'it\u2019s'] . Once defined call the function and print its outcome. Hint: in python the function {string}.split({separator}) splits a string into a list of words using {separator} as splitter between the words in the string. For instance, \"Hi my name is James\".split(\" \") -> [\"Hi\", \"my\", \"name\", \"is\", \"James\"] Show solution def clean_lyrics(txt_lyrics): lyrics_set = set(txt_lyrics.split(\" \")) unwanted_list = ['a', 'i', 'am', 'to', ';;', 'the', 'you', 'don\u2019t', 'and', 'that', 'i\u2019m', 'it\u2019s'] unwanted_set = set(unwanted_list) clean_set = lyrics_set.difference(unwanted_set) return clean_set print(clean_lyrics(lyrics)) 1.b) Define the function family_words() which takes the outcome of clean_lyrics() as parameter and return the number of words that are also part of the following list [\"mama\",\"daddy\",\"sister\",\"brother\",\"boy\",\"girl\"] . Show solution def family_words(l_words): clean_set = set(l_words) l_words = [\"mama\", \"daddy\", \"sister\", \"brother\", \"boy\", \"girl\"] s_words = set(l_words) common_set = clean_set.intersection(s_words) return len(common_set) l_clean_lyrics = family_words(clean_lyrics(lyrics)) print(l_clean_lyrics) 1.c) Define the function count_words() which takes lyrics as parameter and returns a dictionary with all the unique words as keys and the occurrences of each word as value. The dictionary must not include the following words ['a', 'i', 'am', 'to', ';;', 'the', 'you', 'don\u2019t', 'and', 'that', 'i\u2019m', 'it\u2019s'] . Show solution def count_words(txt_lyrics): result_dict = {} lyrics_l = txt_lyrics.split(\" \") unwated_list = ['a', 'i', 'am', 'to', ';;', 'the', 'you', 'don\u2019t', 'and', 'that', 'i\u2019m', 'it\u2019s'] for w in lyrics_l: if w not in unwated_list: if w not in result_dict: result_dict[w] = 0 result_dict[w] += 1 return result_dict count_dict = count_words(lyrics) print(count_dict) 1.d) Andrea wants to create a playlist with some songs by The Black Keys. He wrote down on a paper the list of songs he would like to include. For each song first, he wrote the name of the album and then the title of the song contained in it. The two values are separated using \"::\" . For instance, in el_camino::lonely_boy the album name is \"el_camino\" and \"lonely_boy\" is the title of the song. Here we have the entire playlist of Andrea, the songs are separated by \";;\" : playlist_txt = \"el camino::lonely boy ;; el camino::little black submarine ;; el camino::gold on the ceiling ;; turn blue::fever ;; turn blue::gotta get away ;; brothers::howlin for you ;; brothers::tighten up ;; turn blue::it is up to you now\" Define the function build_playlist_dict() which takes playlist_txt as parameter and creates a dictionary having the album titles as keys each key will have the list of all its corresponding songs. Show solution def build_playlist_dict(a_txt): result_dict = {} songs = a_txt.split(\" ;; \") for a_song in songs: song_parts = a_song.split(\"::\") album = song_parts[0] song_name = song_parts[1] if album not in result_dict: result_dict[album] = [] result_dict[album].append(song_name) return result_dict print(build_playlist_dict(playlist_txt)) 2nd Exercise Giving a collection of pokemon cards (i.e. a list) we want to readapt it following the pokemon-evolution rules, such that if we have two cards in our deck representing the same pokemon we must replace them with one card representing the evolved version of that pokemon. The evolution rules are defined in the following dictionary: evolution_map = { \"Poliwag\": \"Poliwhirl\", \"Bulbasaur\": \"Ivysaur\", \"Charmander\": \"Charmeleon\", \"Pidgey\": \"Pidgeotto\", \"Psyduck\": \"Golduck\", \"Abra\": \"Kadabra\" } For instance: l_cards = [\"Poliwag\", \"Pidgey\", \"Abra\", \"Pidgey\", \"Charmander\", \"Bulbasaur\", \"Charmander\", \"Psyduck\", \"Poliwag\",\"Goldeen\"] # The new list should be: # ['Poliwhirl', 'Charmeleon', 'Bulbasaur', 'Psyduck', 'Pidgeotto', 'Goldeen', 'Abra'] Define the function pokemon_cards() which takes a list of pokemon cards and returns a new list of pokemon cards which follows the pokemon-evolution rules. Show solution def pokemon_cards(l_pokemons): card_checked = set() new_l_pokemons = list() for pok in l_pokemons: if pok not in card_checked: num_occ = 0 for pok_check in l_pokemons: if pok_check == pok: num_occ += 1 if num_occ > 1: pok_evol = evolution_map[pok] new_l_pokemons.append(pok_evol) else: new_l_pokemons.append(pok) card_checked.add(pok) return new_l_pokemons","title":"4. Working with unordered structures"},{"location":"chapter/04/#working-with-unordered-structures","text":"","title":"Working with unordered structures"},{"location":"chapter/04/#sets","text":"A collection of unordered and unindexed items We use Sets in order to have a collection without duplicates The items of a set can't be accessed by referring to an index or a key A Set contains only immutable data types, e.g. strings, numbers, or tuples # create a set of string items a_set = {\"Roma\", \"Torino\", \"Bologna\"} # create a set from a list a_set = set([\"Roma\", \"Torino\", \"Bologna\",\"Roma\"]) # add an item to the set a_set.add(\"Palermo\") # remove an item from the set a_set.remove(\"Palermo\") # raise an error if the item isn't found a_set.discard(\"Palermo\") # doesn't raise errors if the item isn't found #ERROR: we can't add a mutable item to the set a_set.add([\"Rimini\",\"Firenze\"]) # some operations: union, intersection, difference ... etc b_set = {\"Napoli\", \"Bari\", \"Lecce\", \"Roma\"} new_set = a_set.union(b_set) #OUTPUT: {'Bari', 'Bologna', 'Lecce', 'Napoli', 'Roma', 'Torino'} new_set = a_set.intersection(b_set) #OUTPUT: {'Roma'} new_set = a_set.difference(b_set) #OUTPUT: {'Bologna', 'Torino'}","title":"Sets"},{"location":"chapter/04/#dictionaries","text":"A data structure that can store data in the form of key-value pairs It provides an efficient and useful way for organizing the data under specific typologies (keys) The items of a dictionary are accessed by specifying a key The key values should be immutable data types, e.g. strings, numbers, or tuples A dictionary can't contain duplicate keys # create a dictionary ages_dict = {} # add a new (key,value) pair ages_dict[\"Marco\"] = 25 ages_dict[\"Alessia\"] = 22 ages_dict[\"Giulia\"] = 21 #OUTPUT: {'Marco': 25, 'Alessia':22, 'Giulia':21} # accessing an item print(ages_dict[\"Marco\"]) # remove an item from the dictionary del ages_dict[\"Marco\"] # important methods ages_dict.items() #returns a sequence of (key,value) pairs #OUTPUT: [('Alessia',22),('Giulia',21)] a_dict = {\"Pippo\":34} ages_dict.update(a_dict) #updates ages_dict with the (key,value) pairs of a_dict #OUTPUT: {'Alessia': 22, 'Giulia':21, 'Pippo':34}","title":"Dictionaries"},{"location":"chapter/04/#exercises","text":"","title":"Exercises"},{"location":"chapter/04/#1st-exercise","text":"The variable lyrics contains the lyrics (string value) of the song \"Lonely Boy\" by \"The Black Keys\". The words are all written in lowercase and the line breaks are represented with ;; lyrics = \"well i\u2019m so above you ;; and it\u2019s plain to see ;; but i came to love you anyway ;; so you pulled my heart out ;; and i don\u2019t mind bleeding ;; any old time you keep me waiting ;; waiting, waiting ;; oh, oh-oh i got a love that keeps me waiting ;; oh, oh-oh i got a love that keeps me waiting ;; i\u2019m a lonely boy ;; i\u2019m a lonely boy ;; oh, oh-oh i got a love that keeps me waiting ;; well your mama kept you but your daddy left you ;; and i should\u2019ve done you just the same ;; but i came to love you ;; am i born to bleed? ;; any old time you keep me waiting ;; waiting, waiting ;; oh, oh-oh i got a love that keeps me waiting ;; oh, oh-oh i got a love that keeps me waiting ;; i\u2019m a lonely boy ;; i\u2019m a lonely boy ;; oh, oh-oh i got a love that keeps me waiting ;; hey! ;; oh, oh-oh i got a love that keeps me waiting ;; oh, oh-oh i got a love that keeps me waiting ;; i\u2019m a lonely boy ;; i\u2019m a lonely boy ;; oh, oh-oh i got a love that keeps me waiting\" 1.a) Define the function clean_lyrics() which takes lyrics as parameter and returns a set of all the unique words of the song excluding the following words ['a', 'i', 'am', 'to', ';;', 'the', 'you', 'don\u2019t', 'and', 'that', 'i\u2019m', 'it\u2019s'] . Once defined call the function and print its outcome. Hint: in python the function {string}.split({separator}) splits a string into a list of words using {separator} as splitter between the words in the string. For instance, \"Hi my name is James\".split(\" \") -> [\"Hi\", \"my\", \"name\", \"is\", \"James\"] Show solution def clean_lyrics(txt_lyrics): lyrics_set = set(txt_lyrics.split(\" \")) unwanted_list = ['a', 'i', 'am', 'to', ';;', 'the', 'you', 'don\u2019t', 'and', 'that', 'i\u2019m', 'it\u2019s'] unwanted_set = set(unwanted_list) clean_set = lyrics_set.difference(unwanted_set) return clean_set print(clean_lyrics(lyrics)) 1.b) Define the function family_words() which takes the outcome of clean_lyrics() as parameter and return the number of words that are also part of the following list [\"mama\",\"daddy\",\"sister\",\"brother\",\"boy\",\"girl\"] . Show solution def family_words(l_words): clean_set = set(l_words) l_words = [\"mama\", \"daddy\", \"sister\", \"brother\", \"boy\", \"girl\"] s_words = set(l_words) common_set = clean_set.intersection(s_words) return len(common_set) l_clean_lyrics = family_words(clean_lyrics(lyrics)) print(l_clean_lyrics) 1.c) Define the function count_words() which takes lyrics as parameter and returns a dictionary with all the unique words as keys and the occurrences of each word as value. The dictionary must not include the following words ['a', 'i', 'am', 'to', ';;', 'the', 'you', 'don\u2019t', 'and', 'that', 'i\u2019m', 'it\u2019s'] . Show solution def count_words(txt_lyrics): result_dict = {} lyrics_l = txt_lyrics.split(\" \") unwated_list = ['a', 'i', 'am', 'to', ';;', 'the', 'you', 'don\u2019t', 'and', 'that', 'i\u2019m', 'it\u2019s'] for w in lyrics_l: if w not in unwated_list: if w not in result_dict: result_dict[w] = 0 result_dict[w] += 1 return result_dict count_dict = count_words(lyrics) print(count_dict) 1.d) Andrea wants to create a playlist with some songs by The Black Keys. He wrote down on a paper the list of songs he would like to include. For each song first, he wrote the name of the album and then the title of the song contained in it. The two values are separated using \"::\" . For instance, in el_camino::lonely_boy the album name is \"el_camino\" and \"lonely_boy\" is the title of the song. Here we have the entire playlist of Andrea, the songs are separated by \";;\" : playlist_txt = \"el camino::lonely boy ;; el camino::little black submarine ;; el camino::gold on the ceiling ;; turn blue::fever ;; turn blue::gotta get away ;; brothers::howlin for you ;; brothers::tighten up ;; turn blue::it is up to you now\" Define the function build_playlist_dict() which takes playlist_txt as parameter and creates a dictionary having the album titles as keys each key will have the list of all its corresponding songs. Show solution def build_playlist_dict(a_txt): result_dict = {} songs = a_txt.split(\" ;; \") for a_song in songs: song_parts = a_song.split(\"::\") album = song_parts[0] song_name = song_parts[1] if album not in result_dict: result_dict[album] = [] result_dict[album].append(song_name) return result_dict print(build_playlist_dict(playlist_txt))","title":"1st Exercise"},{"location":"chapter/04/#2nd-exercise","text":"Giving a collection of pokemon cards (i.e. a list) we want to readapt it following the pokemon-evolution rules, such that if we have two cards in our deck representing the same pokemon we must replace them with one card representing the evolved version of that pokemon. The evolution rules are defined in the following dictionary: evolution_map = { \"Poliwag\": \"Poliwhirl\", \"Bulbasaur\": \"Ivysaur\", \"Charmander\": \"Charmeleon\", \"Pidgey\": \"Pidgeotto\", \"Psyduck\": \"Golduck\", \"Abra\": \"Kadabra\" } For instance: l_cards = [\"Poliwag\", \"Pidgey\", \"Abra\", \"Pidgey\", \"Charmander\", \"Bulbasaur\", \"Charmander\", \"Psyduck\", \"Poliwag\",\"Goldeen\"] # The new list should be: # ['Poliwhirl', 'Charmeleon', 'Bulbasaur', 'Psyduck', 'Pidgeotto', 'Goldeen', 'Abra'] Define the function pokemon_cards() which takes a list of pokemon cards and returns a new list of pokemon cards which follows the pokemon-evolution rules. Show solution def pokemon_cards(l_pokemons): card_checked = set() new_l_pokemons = list() for pok in l_pokemons: if pok not in card_checked: num_occ = 0 for pok_check in l_pokemons: if pok_check == pok: num_occ += 1 if num_occ > 1: pok_evol = evolution_map[pok] new_l_pokemons.append(pok_evol) else: new_l_pokemons.append(pok) card_checked.add(pok) return new_l_pokemons","title":"2nd Exercise"},{"location":"chapter/05/","text":"Recursion and working with files Recursion What is it about? The process of defining something in terms of itself In Python, this happens when a function calls itself Why do we need it? The code looks clean and elegant A complex task is broken down into simpler sub-problems Some data structures like trees are easier to explore using recursion # Example: recursive function for calculating n! (factorial) def factorial_recursive(n): #Base case if n == 1: return 1 #Recursive case: n * (n-1)! else: return n * factorial_recursive(n-1) print(factorial_recursive(5)) #OUTPUT: 120 Reading and writing files In Python, we can read external files and create/write new files with content inside We need to provide the location of the file inside our system, i.e., the path to the file. If the path is in the current working directory, you can just provide the filename myfile.txt . If not, then you have to provide the path of the file DIRECTORY_NAME/myfile.txt . We have two types of paths Absolute file path: are notated by a leading forward (\"/\") slash or drive label (e.g., \"C:\"). The path starts from the root of the file system. E.g. /DIRECTORY_1/MY_PROJ_DIRECTORY/MY_PROJ_FILES/myfile.txt Relative file path: are notated by a lack of a leading forward slash or drive label. It is interpreted from the perspective of your current working directory. MY_PROJ_FILES/myfile.txt /DIRECTORY_1/MY_PROJ_DIRECTORY/MY_PROJ_FILES/myfile.txt MY_PROJ_FILES/myfile.txt # Writing a file: with open(\"files/txt_sample.txt\",\"w\") as my_file: my_file.write(\"the file content!\") # Reading a file: with open(\"files/txt_sample.txt\",\"r\") as my_file: for line in my_file: print(line) CSV and JSON files A comma-separated values (CSV) file is a delimited text file that uses a comma to separate values. Each line of the file is a data record. Each record consists of one or more fields, separated by commas. A CSV file typically stores tabular data (numbers and text) in plain text, in which case each line will have the same number of fields. import csv # Reading a CSV file: with open('files/csv_sample.csv', mode='r') as file: csvFile = csv.reader(file) for line in csvFile: print(line) # Writing a CSV file: with open('files/csv_sample.csv', mode='w') as csvfile: csvwriter = csv.writer(csvfile) # fields is a list values fields = [\"roma\",\"torino\",\"milano\"] csvwriter.writerow(fields) # rows is a list of lists rows = [[\"genova\",\"bologna\",\"parma\"], [\"palermo\",\"napoli\",\"bari\"]] csvwriter.writerows(rows) A JSON file is used to transmit data objects consisting of attribute\u2013value pairs and array data types import json # Reading a JSON file: with open('files/json_sample.json', mode='r') as jsonfile: json_object = json.load(jsonfile) # Writing a JSON file: with open('files/json_sample.json', mode='w') as jsonfile: a_dict = {\"Federico\":35,\"Stefano\":22,\"Sandro\":31} json.dump(a_dict, jsonfile) Exercises 1st Exercise We want to define a recursive function that simulates a pokemon tournament. The number of pokemons participating in the tournament is 8. Each pokemon is defined using 3 values: (1)name, (2)attack-points, and (3) defense-points. A pokemon could be therefore characterized using a tuple of 3 elements, e.g. (\"Poliwag\",10,5) . The tournament could be defined as a list of 8 pokemons (i.e. tuple). For instance: pokemon_tournament = [(\"Poliwag\",10,5),(\"Charmander\",15,2),(\"Abra\",8,7),(\"Pidgey\",4,5),(\"Goldeen\",6,8),(\"Bulbasaur\",12,10),(\"Charmeleon\",18,8),(\"Psyduck\",3,4)] To determine the champion of the tournament 2 nearby pokemons (according to their order in the list) compete. The pokemon on the left uses the attack-points (second value of the tuple), while the right one uses the defense-points (third value of the tuple), if the attack-points are higher than the defense-points then the pokemon on the left side goes up to the next round, otherwise, the pokemon on the right side does that. The same process will be repeated in the second round too. The tournament ends when we have 1 final winner. For example the winner of the tournament pokemon_tournament is: # ROUND 1: (\"Poliwag\",10,5)vs(\"Charmander\",15,2) | (\"Abra\",8,7)vs(\"Pidgey\",4,5) | (\"Goldeen\",6,8)vs(\"Bulbasaur\",12,10) | (\"Charmeleon\",18,8)vs(\"Psyduck\",3,4) # ROUND 2: (\"Poliwag\",10,5)vs(\"Abra\",8,7) | (\"Bulbasaur\",12,10)vs(\"Charmeleon\",18,8) # THE FINAL: (\"Poliwag\",10,5)vs(\"Bulbasaur\",12,10) # THE WINNER: (\"Bulbasaur\",12,10) Define a recursive function called pokemon_champion() which takes a tournament (i.e. a list of pokemons) and returns the updated tournament list containing only the champion of the tournament. For instance pokemon_champion(pokemon_tournament) returns the list [ (\"Bulbasaur\",12,10) ] Show solution def pokemon_champion(pokemon_list): len_list = len(pokemon_list) if len_list == 1: return [pokemon_list[0]] elif len_list == 2: p_attack = pokemon_list[0][1] p_defend = pokemon_list[1][2] if p_attack > p_defend: return [pokemon_list[0]] else: return [pokemon_list[1]] else: mid = len_list // 2 return pokemon_champion(pokemon_champion(pokemon_list[:mid]) + pokemon_champion(pokemon_list[mid:])) 2nd Exercise The CSV file pokemon_list.csv contains a list of all the pokemons with their attacking and defending points, such that it contains three columns (in order): \"Name\",\"Attack\",\"Defense\". The total number of pokemons is 800. 2.a) Download the file pokemon_list.csv on your local machine. Write a portion of code in python to read and convert the CSV file into a list of tuples and simulate a mega tournament using the function defined in 1st Exercise (in this case there is no limit of partecipants to the tournament, i.e. previously set to 8). Show solution # Reading a CSV file: l_of_pokemons = list() with open('<RELATIVE-PATH>/pokemon_list.csv', mode='r') as file: csvFile = csv.reader(file) next(csvFile) for line in csvFile: l_of_pokemons.append(tuple(line)) print(pokemon_champion(l_of_pokemons)) 2.b) Run the mega tournament 100 times and keep track of all the winners. Each time shuffle randomly the list of pokemons before running the tournament. Note one pokemon might win multiple times. For each winner keep a count for the total number tournament wins. Hint: the function random.shuffle() shuffles randomly the items of a given list. Note: you must import the random library, i.e., import random . Example: random.shuffle([1,2,3,4,5]) => [3,2,1,5,4] Show solution import random winners_dict = {} for i in range(0,100): random.shuffle(l_of_pokemons) pok_winner = pokemon_champion(l_of_pokemons)[0][0] if pok_winner not in winners_dict: winners_dict[pok_winner] = 1 winners_dict[pok_winner] += 1 print(winners_dict)","title":"5. Recursion and working with files"},{"location":"chapter/05/#recursion-and-working-with-files","text":"","title":"Recursion and working with files"},{"location":"chapter/05/#recursion","text":"What is it about? The process of defining something in terms of itself In Python, this happens when a function calls itself Why do we need it? The code looks clean and elegant A complex task is broken down into simpler sub-problems Some data structures like trees are easier to explore using recursion # Example: recursive function for calculating n! (factorial) def factorial_recursive(n): #Base case if n == 1: return 1 #Recursive case: n * (n-1)! else: return n * factorial_recursive(n-1) print(factorial_recursive(5)) #OUTPUT: 120","title":"Recursion"},{"location":"chapter/05/#reading-and-writing-files","text":"In Python, we can read external files and create/write new files with content inside We need to provide the location of the file inside our system, i.e., the path to the file. If the path is in the current working directory, you can just provide the filename myfile.txt . If not, then you have to provide the path of the file DIRECTORY_NAME/myfile.txt . We have two types of paths Absolute file path: are notated by a leading forward (\"/\") slash or drive label (e.g., \"C:\"). The path starts from the root of the file system. E.g. /DIRECTORY_1/MY_PROJ_DIRECTORY/MY_PROJ_FILES/myfile.txt Relative file path: are notated by a lack of a leading forward slash or drive label. It is interpreted from the perspective of your current working directory. MY_PROJ_FILES/myfile.txt /DIRECTORY_1/MY_PROJ_DIRECTORY/MY_PROJ_FILES/myfile.txt MY_PROJ_FILES/myfile.txt # Writing a file: with open(\"files/txt_sample.txt\",\"w\") as my_file: my_file.write(\"the file content!\") # Reading a file: with open(\"files/txt_sample.txt\",\"r\") as my_file: for line in my_file: print(line)","title":"Reading and writing files"},{"location":"chapter/05/#csv-and-json-files","text":"A comma-separated values (CSV) file is a delimited text file that uses a comma to separate values. Each line of the file is a data record. Each record consists of one or more fields, separated by commas. A CSV file typically stores tabular data (numbers and text) in plain text, in which case each line will have the same number of fields. import csv # Reading a CSV file: with open('files/csv_sample.csv', mode='r') as file: csvFile = csv.reader(file) for line in csvFile: print(line) # Writing a CSV file: with open('files/csv_sample.csv', mode='w') as csvfile: csvwriter = csv.writer(csvfile) # fields is a list values fields = [\"roma\",\"torino\",\"milano\"] csvwriter.writerow(fields) # rows is a list of lists rows = [[\"genova\",\"bologna\",\"parma\"], [\"palermo\",\"napoli\",\"bari\"]] csvwriter.writerows(rows) A JSON file is used to transmit data objects consisting of attribute\u2013value pairs and array data types import json # Reading a JSON file: with open('files/json_sample.json', mode='r') as jsonfile: json_object = json.load(jsonfile) # Writing a JSON file: with open('files/json_sample.json', mode='w') as jsonfile: a_dict = {\"Federico\":35,\"Stefano\":22,\"Sandro\":31} json.dump(a_dict, jsonfile)","title":"CSV and JSON files"},{"location":"chapter/05/#exercises","text":"","title":"Exercises"},{"location":"chapter/05/#1st-exercise","text":"We want to define a recursive function that simulates a pokemon tournament. The number of pokemons participating in the tournament is 8. Each pokemon is defined using 3 values: (1)name, (2)attack-points, and (3) defense-points. A pokemon could be therefore characterized using a tuple of 3 elements, e.g. (\"Poliwag\",10,5) . The tournament could be defined as a list of 8 pokemons (i.e. tuple). For instance: pokemon_tournament = [(\"Poliwag\",10,5),(\"Charmander\",15,2),(\"Abra\",8,7),(\"Pidgey\",4,5),(\"Goldeen\",6,8),(\"Bulbasaur\",12,10),(\"Charmeleon\",18,8),(\"Psyduck\",3,4)] To determine the champion of the tournament 2 nearby pokemons (according to their order in the list) compete. The pokemon on the left uses the attack-points (second value of the tuple), while the right one uses the defense-points (third value of the tuple), if the attack-points are higher than the defense-points then the pokemon on the left side goes up to the next round, otherwise, the pokemon on the right side does that. The same process will be repeated in the second round too. The tournament ends when we have 1 final winner. For example the winner of the tournament pokemon_tournament is: # ROUND 1: (\"Poliwag\",10,5)vs(\"Charmander\",15,2) | (\"Abra\",8,7)vs(\"Pidgey\",4,5) | (\"Goldeen\",6,8)vs(\"Bulbasaur\",12,10) | (\"Charmeleon\",18,8)vs(\"Psyduck\",3,4) # ROUND 2: (\"Poliwag\",10,5)vs(\"Abra\",8,7) | (\"Bulbasaur\",12,10)vs(\"Charmeleon\",18,8) # THE FINAL: (\"Poliwag\",10,5)vs(\"Bulbasaur\",12,10) # THE WINNER: (\"Bulbasaur\",12,10) Define a recursive function called pokemon_champion() which takes a tournament (i.e. a list of pokemons) and returns the updated tournament list containing only the champion of the tournament. For instance pokemon_champion(pokemon_tournament) returns the list [ (\"Bulbasaur\",12,10) ] Show solution def pokemon_champion(pokemon_list): len_list = len(pokemon_list) if len_list == 1: return [pokemon_list[0]] elif len_list == 2: p_attack = pokemon_list[0][1] p_defend = pokemon_list[1][2] if p_attack > p_defend: return [pokemon_list[0]] else: return [pokemon_list[1]] else: mid = len_list // 2 return pokemon_champion(pokemon_champion(pokemon_list[:mid]) + pokemon_champion(pokemon_list[mid:]))","title":"1st Exercise"},{"location":"chapter/05/#2nd-exercise","text":"The CSV file pokemon_list.csv contains a list of all the pokemons with their attacking and defending points, such that it contains three columns (in order): \"Name\",\"Attack\",\"Defense\". The total number of pokemons is 800. 2.a) Download the file pokemon_list.csv on your local machine. Write a portion of code in python to read and convert the CSV file into a list of tuples and simulate a mega tournament using the function defined in 1st Exercise (in this case there is no limit of partecipants to the tournament, i.e. previously set to 8). Show solution # Reading a CSV file: l_of_pokemons = list() with open('<RELATIVE-PATH>/pokemon_list.csv', mode='r') as file: csvFile = csv.reader(file) next(csvFile) for line in csvFile: l_of_pokemons.append(tuple(line)) print(pokemon_champion(l_of_pokemons)) 2.b) Run the mega tournament 100 times and keep track of all the winners. Each time shuffle randomly the list of pokemons before running the tournament. Note one pokemon might win multiple times. For each winner keep a count for the total number tournament wins. Hint: the function random.shuffle() shuffles randomly the items of a given list. Note: you must import the random library, i.e., import random . Example: random.shuffle([1,2,3,4,5]) => [3,2,1,5,4] Show solution import random winners_dict = {} for i in range(0,100): random.shuffle(l_of_pokemons) pok_winner = pokemon_champion(l_of_pokemons)[0][0] if pok_winner not in winners_dict: winners_dict[pok_winner] = 1 winners_dict[pok_winner] += 1 print(winners_dict)","title":"2nd Exercise"},{"location":"chapter/06/","text":"Data analysis on Netflix shows The dataset The dataset netflix_titles.csv contains a list of the tv shows and movies available on Netflix as of 2019 (the dataset is under a CC0 Public Domain license and had been downloaded using kaggle APIs ). Contents The CSV file contains the following columns: show_id : Unique ID for every movie/tv-show type : Type of the show - \"Movie\" or \"TV Show\" title : Title of the show director : Director of the movie cast : Actors involved in the show country : Country where the show was produced date_added : Date it was added on Netflix release_year : Actual Release year of the show rating : TV Rating of the show (used for evaluating the content and reporting the suitability of television programs for children, teenagers, or adults) duration : Total Duration - in minutes or number of seasons listed_in : The category(s) of the show (e.g., Comedies, Independent Movies, Romantic Movies, etc.) description : A description of the show Project initialization Init your project as follow: create a directory and name it netflix_analysis create a python script inside netflix_analysis/ and name it main.py create a python script inside netflix_analysis/ and name it util.py create a directory inside netflix_analysis/ and name it data download (if you have not done it yet) the netflix_titles.csv dataset and put it inside the netflix_analysis/data directory. 1st Exercise \u2013 read the dataset Open the netflix_analysis/util.py file and define the following functions: 1.a) csv_to_matrix() which takes the PATH of a CSV file f_path and returns a matrix (list of lists) representing the CSV contents without including the first row of the CSV (the header). Show solution def csv_to_matrix(f_path): result = [] with open(f_path, mode='r') as csv_file: csv_reader = csv.reader(csv_file, delimiter=',') next(csv_reader) for row in csv_reader: result.append(row) return result 1.b) csv_to_list_of_dict() which takes the PATH of a CSV file f_path and returns a list of dictionaries which represents the CSV contents, such that each element of the list (i.e. a dictionary) represents a row of the CSV. The pairs key-value of the dictionary represents respectively the name of the column and the corresponding value in the cell. Example: [ {\"name\": \"James\", \"age\": 25}, {\"name\":\"David\", \"age\": 28} ] Hint: the function csv.DictReader(csv_file) reads a CSV file and returns a DictReader object, each element of the new object (i.e., a row) is represented as dictionary Show solution def csv_to_list_of_dict(f_path): result = [] with open(f_path, mode='r') as csv_file: csv_reader = csv.DictReader(csv_file) for row in csv_reader: result.append(row) return result 2nd Exercise - statistics on Italian shows Open the netflix_analysis/main.py file and write a portion of code which prints the following informations: a) The titles of all the Netflix shows produced in Italy. b) The total number of Italian movies and the total number of Italian tv shows. c) The number of Italian shows for each different year of their release Show solution import csv from util import * netflix_data = csv_to_list_of_dict(\"netflix_analysis/data/netflix_titles.csv\") # a ---- italian_shows = [] for row in netflix_data: if \"Italy\" in row[\"country\"].split(\", \"): italian_shows.append(row) for ita_show in italian_shows: print(ita_show[\"title\"]) # b ---- count_movies = 0 count_tvshows = 0 for ita_show in italian_shows: show_type = ita_show[\"type\"] if show_type == \"Movie\": count_movies += 1 elif show_type == \"TV Show\": count_tvshows += 1 print(count_movies, count_tvshows) # c ---- ita_shows_by_year = dict() for ita_show in italian_shows: release_year = ita_show[\"release_year\"] if release_year not in ita_shows_by_year: ita_shows_by_year[release_year] = 0 ita_shows_by_year[release_year] += 1 3rd Exercise - general statistics Open the netflix_analysis/main.py file and write a portion of code which: a) Detects the director with the higher number of shows and prints his name b) Creates an index that contains all the countries, and for each country the number of shows classified according to the genere of the show (e.g., Comedies, Documentaries, etc) Show solution from util import * netflix_data = csv_to_list_of_dict(\"netflix_analysis/data/netflix_titles.csv\") # a ---- directors_index = dict() max_val = 0 max_name = None for row in netflix_data: for director in row[\"director\"].split(\", \"): # detect the empty values if director == \"\": continue if director not in directors_index: directors_index[director] = 0 directors_index[director] += 1 # check if the new value is higher than max new_val = directors_index[director] if new_val > max_val: max_name, max_val = director, new_val print(max_name, max_val) # b ---- country_cat_index = dict() for row in netflix_data: for country in row[\"country\"].split(\", \"): # detect the empty values if country == \"\": continue # The value is OK, so ... if country not in country_cat_index: country_cat_index[country] = dict() for cat in row[\"listed_in\"].split(\", \"): # detect the empty values if cat == \"\": continue # The value is OK, so ... if cat not in country_cat_index[country]: country_cat_index[country][cat] = 0 country_cat_index[country][cat] += 1","title":"6. Data analysis on Netflix shows"},{"location":"chapter/06/#data-analysis-on-netflix-shows","text":"","title":"Data analysis on Netflix shows"},{"location":"chapter/06/#the-dataset","text":"The dataset netflix_titles.csv contains a list of the tv shows and movies available on Netflix as of 2019 (the dataset is under a CC0 Public Domain license and had been downloaded using kaggle APIs ).","title":"The dataset"},{"location":"chapter/06/#contents","text":"The CSV file contains the following columns: show_id : Unique ID for every movie/tv-show type : Type of the show - \"Movie\" or \"TV Show\" title : Title of the show director : Director of the movie cast : Actors involved in the show country : Country where the show was produced date_added : Date it was added on Netflix release_year : Actual Release year of the show rating : TV Rating of the show (used for evaluating the content and reporting the suitability of television programs for children, teenagers, or adults) duration : Total Duration - in minutes or number of seasons listed_in : The category(s) of the show (e.g., Comedies, Independent Movies, Romantic Movies, etc.) description : A description of the show","title":"Contents"},{"location":"chapter/06/#project-initialization","text":"Init your project as follow: create a directory and name it netflix_analysis create a python script inside netflix_analysis/ and name it main.py create a python script inside netflix_analysis/ and name it util.py create a directory inside netflix_analysis/ and name it data download (if you have not done it yet) the netflix_titles.csv dataset and put it inside the netflix_analysis/data directory.","title":"Project initialization"},{"location":"chapter/06/#1st-exercise-read-the-dataset","text":"Open the netflix_analysis/util.py file and define the following functions: 1.a) csv_to_matrix() which takes the PATH of a CSV file f_path and returns a matrix (list of lists) representing the CSV contents without including the first row of the CSV (the header). Show solution def csv_to_matrix(f_path): result = [] with open(f_path, mode='r') as csv_file: csv_reader = csv.reader(csv_file, delimiter=',') next(csv_reader) for row in csv_reader: result.append(row) return result 1.b) csv_to_list_of_dict() which takes the PATH of a CSV file f_path and returns a list of dictionaries which represents the CSV contents, such that each element of the list (i.e. a dictionary) represents a row of the CSV. The pairs key-value of the dictionary represents respectively the name of the column and the corresponding value in the cell. Example: [ {\"name\": \"James\", \"age\": 25}, {\"name\":\"David\", \"age\": 28} ] Hint: the function csv.DictReader(csv_file) reads a CSV file and returns a DictReader object, each element of the new object (i.e., a row) is represented as dictionary Show solution def csv_to_list_of_dict(f_path): result = [] with open(f_path, mode='r') as csv_file: csv_reader = csv.DictReader(csv_file) for row in csv_reader: result.append(row) return result","title":"1st Exercise \u2013 read the dataset"},{"location":"chapter/06/#2nd-exercise-statistics-on-italian-shows","text":"Open the netflix_analysis/main.py file and write a portion of code which prints the following informations: a) The titles of all the Netflix shows produced in Italy. b) The total number of Italian movies and the total number of Italian tv shows. c) The number of Italian shows for each different year of their release Show solution import csv from util import * netflix_data = csv_to_list_of_dict(\"netflix_analysis/data/netflix_titles.csv\") # a ---- italian_shows = [] for row in netflix_data: if \"Italy\" in row[\"country\"].split(\", \"): italian_shows.append(row) for ita_show in italian_shows: print(ita_show[\"title\"]) # b ---- count_movies = 0 count_tvshows = 0 for ita_show in italian_shows: show_type = ita_show[\"type\"] if show_type == \"Movie\": count_movies += 1 elif show_type == \"TV Show\": count_tvshows += 1 print(count_movies, count_tvshows) # c ---- ita_shows_by_year = dict() for ita_show in italian_shows: release_year = ita_show[\"release_year\"] if release_year not in ita_shows_by_year: ita_shows_by_year[release_year] = 0 ita_shows_by_year[release_year] += 1","title":"2nd Exercise - statistics on Italian shows"},{"location":"chapter/06/#3rd-exercise-general-statistics","text":"Open the netflix_analysis/main.py file and write a portion of code which: a) Detects the director with the higher number of shows and prints his name b) Creates an index that contains all the countries, and for each country the number of shows classified according to the genere of the show (e.g., Comedies, Documentaries, etc) Show solution from util import * netflix_data = csv_to_list_of_dict(\"netflix_analysis/data/netflix_titles.csv\") # a ---- directors_index = dict() max_val = 0 max_name = None for row in netflix_data: for director in row[\"director\"].split(\", \"): # detect the empty values if director == \"\": continue if director not in directors_index: directors_index[director] = 0 directors_index[director] += 1 # check if the new value is higher than max new_val = directors_index[director] if new_val > max_val: max_name, max_val = director, new_val print(max_name, max_val) # b ---- country_cat_index = dict() for row in netflix_data: for country in row[\"country\"].split(\", \"): # detect the empty values if country == \"\": continue # The value is OK, so ... if country not in country_cat_index: country_cat_index[country] = dict() for cat in row[\"listed_in\"].split(\", \"): # detect the empty values if cat == \"\": continue # The value is OK, so ... if cat not in country_cat_index[country]: country_cat_index[country][cat] = 0 country_cat_index[country][cat] += 1","title":"3rd Exercise - general statistics"},{"location":"chapter/7_lesson/","text":"Data analysis of the Netflix shows - part 2 Date: 04/12/2020 Time: 12:30-14:30 Text analysis Natural Language Processing (NLP) is about developing applications and services that can understand human languages. Nowadays we have millions of gigabytes of data generated every day by blogs, social websites, and web pages. A big data analysis using NLP applications can turn out to be very beneficial. Possible NLP applications are speech recognition/translation, semantic analysis of the words, the syntactical/grammatical analysis of the sentences and paragraphs, and others. The analysis of the text is a common and main task in NLP. We will focus on some basic text analysis operations and how are they performed using Python. Note: If you are interested in a further application of NLP methods in python (beyond the materials of this lesson), I suggest you to read the following article: https://medium.com/towards-artificial-intelligence/text-mining-in-python-steps-and-examples-78b3f8fd913b The NLTK library The Natural language toolkit (NLTK) is a very popular library for natural language processing in python and it has a large active community behind it. We need to install it: pip3 install nltk To check if the NLTK library has been correctly installed we need to import it in our python script: Import nltk If every thing looks fine we will install/download popular nltk packages. We will download the popular and essential ones used for working with the basic nltk operations. Write the following line in your python script (after importing nltk): nltk.download(\"popular\") Note: In case running the above commands returns an error message: \"CERTIFICATE_VERIFY_FAILED\" , then write in your script only the following lines and run it again. import nltk import ssl try: _create_unverified_https_context = ssl._create_unverified_context except AttributeError: pass else: ssl._create_default_https_context = _create_unverified_https_context nltk.download() If you still have some errors please follow these instructions https://www.xspdf.com/help/50406704.html Tokenization and stopwords removal First thing we want to do is a Tokenization and Stopwords removal . Tokenization is the process of separating and classifying different sections of a string. The resulting tokens are then passed on to some other form of processing. For example: If we want to tokenize the sentence \"Hi I am Marco and I am a DHDK student\" Our list of tokens would be: \"Hi\", \"I\", \"am\", \"Marco\", \"and\", \"I\", \"am\", \"a\", \"DHDK\", \"student\" Stopwords removal these are words that may not carry any valuable information, like articles (e.g. \"the\"), conjunctions (e.g. \"and\"), or propositions (e.g. \"with\"). For example: If we want to remove the stop words from the list of tokens \"Hi\", \"I\", \"am\", \"Marco\", \"and\", \"I\", \"am\", \"a\", \"DHDK\", \"student\" Then our new list could be: \"Hi\", \"Marco\", \"DHDK\", \"student\" Toward a text analysis of the Netflix shows dataset (see also the github repository ) Lets see an example in python first from nltk.corpus import stopwords from nltk.tokenize import word_tokenize example_sent = \"I want to tokenize and remove all the stopwords from this sentence\" # Tokenize the given sentence word_tokens = word_tokenize(example_sent) # Filter the stopwords stop_words = set(stopwords.words('english')) filtered_sentence = [] for w in word_tokens: if not w in stop_words: filtered_sentence.append(w) print(filtered_sentence a) define a function netflix_titles_tokens() which returns a collection of all the different tokens/words in the Netflix shows titles. The collection should not include the stopwords. Mark the box to see the solution from nltk.corpus import stopwords from nltk.tokenize import word_tokenize def netflix_titles_tokens(): stop_words = set(stopwords.words('english')) result = set() for show in netflix_data: word_tokens = word_tokenize(show[\"title\"]) filtered_sentence = [] for w in word_tokens: if not w in stop_words: filtered_sentence.append(w) result.update(filtered_sentence) return result print(netflix_titles_tokens()) b) define a function netflix_director_names() which returns a collection of all the tokens/words included in the director field of the Netflix shows dataset. Each token must be accompanied with a number representing its frequency in the dataset. Hint: Importing from nltk.probability import FreqDist and using FreqDist({LIST_OF_TOKENS}) returns a dictionary, such that the dictionary key is a token and its value is the number of times it appears in the given list. To print the results you can use {FREQ_DIST_DICT}.most_common({N}) , this function prints the {N} most frequent terms inside the dictionary {FREQ_DIST_DICT}. For example: FreqDist([\"hi\",\"bye\",\"ciao\",\"bye\",\"hi\"]) returns {\"hi\": 2, \"bye\":2, \"ciao\": 1} Mark the box to see the solution from nltk.probability import FreqDist def netflix_director_names(): result = [] for show in netflix_data: word_tokens = word_tokenize(show[\"director\"]) result += word_tokens return FreqDist(result) counts = netflix_director_names()","title":"Data analysis of the Netflix shows - part 2"},{"location":"chapter/7_lesson/#data-analysis-of-the-netflix-shows-part-2","text":"","title":"Data analysis of the Netflix shows - part 2"},{"location":"chapter/7_lesson/#text-analysis","text":"Natural Language Processing (NLP) is about developing applications and services that can understand human languages. Nowadays we have millions of gigabytes of data generated every day by blogs, social websites, and web pages. A big data analysis using NLP applications can turn out to be very beneficial. Possible NLP applications are speech recognition/translation, semantic analysis of the words, the syntactical/grammatical analysis of the sentences and paragraphs, and others. The analysis of the text is a common and main task in NLP. We will focus on some basic text analysis operations and how are they performed using Python. Note: If you are interested in a further application of NLP methods in python (beyond the materials of this lesson), I suggest you to read the following article: https://medium.com/towards-artificial-intelligence/text-mining-in-python-steps-and-examples-78b3f8fd913b","title":"Text analysis"},{"location":"chapter/7_lesson/#the-nltk-library","text":"The Natural language toolkit (NLTK) is a very popular library for natural language processing in python and it has a large active community behind it. We need to install it: pip3 install nltk To check if the NLTK library has been correctly installed we need to import it in our python script: Import nltk If every thing looks fine we will install/download popular nltk packages. We will download the popular and essential ones used for working with the basic nltk operations. Write the following line in your python script (after importing nltk): nltk.download(\"popular\") Note: In case running the above commands returns an error message: \"CERTIFICATE_VERIFY_FAILED\" , then write in your script only the following lines and run it again. import nltk import ssl try: _create_unverified_https_context = ssl._create_unverified_context except AttributeError: pass else: ssl._create_default_https_context = _create_unverified_https_context nltk.download() If you still have some errors please follow these instructions https://www.xspdf.com/help/50406704.html","title":"The NLTK library"},{"location":"chapter/7_lesson/#tokenization-and-stopwords-removal","text":"First thing we want to do is a Tokenization and Stopwords removal . Tokenization is the process of separating and classifying different sections of a string. The resulting tokens are then passed on to some other form of processing. For example: If we want to tokenize the sentence \"Hi I am Marco and I am a DHDK student\" Our list of tokens would be: \"Hi\", \"I\", \"am\", \"Marco\", \"and\", \"I\", \"am\", \"a\", \"DHDK\", \"student\" Stopwords removal these are words that may not carry any valuable information, like articles (e.g. \"the\"), conjunctions (e.g. \"and\"), or propositions (e.g. \"with\"). For example: If we want to remove the stop words from the list of tokens \"Hi\", \"I\", \"am\", \"Marco\", \"and\", \"I\", \"am\", \"a\", \"DHDK\", \"student\" Then our new list could be: \"Hi\", \"Marco\", \"DHDK\", \"student\"","title":"Tokenization and stopwords removal"},{"location":"chapter/7_lesson/#toward-a-text-analysis-of-the-netflix-shows-dataset-see-also-the-github-repository","text":"Lets see an example in python first from nltk.corpus import stopwords from nltk.tokenize import word_tokenize example_sent = \"I want to tokenize and remove all the stopwords from this sentence\" # Tokenize the given sentence word_tokens = word_tokenize(example_sent) # Filter the stopwords stop_words = set(stopwords.words('english')) filtered_sentence = [] for w in word_tokens: if not w in stop_words: filtered_sentence.append(w) print(filtered_sentence a) define a function netflix_titles_tokens() which returns a collection of all the different tokens/words in the Netflix shows titles. The collection should not include the stopwords. Mark the box to see the solution from nltk.corpus import stopwords from nltk.tokenize import word_tokenize def netflix_titles_tokens(): stop_words = set(stopwords.words('english')) result = set() for show in netflix_data: word_tokens = word_tokenize(show[\"title\"]) filtered_sentence = [] for w in word_tokens: if not w in stop_words: filtered_sentence.append(w) result.update(filtered_sentence) return result print(netflix_titles_tokens()) b) define a function netflix_director_names() which returns a collection of all the tokens/words included in the director field of the Netflix shows dataset. Each token must be accompanied with a number representing its frequency in the dataset. Hint: Importing from nltk.probability import FreqDist and using FreqDist({LIST_OF_TOKENS}) returns a dictionary, such that the dictionary key is a token and its value is the number of times it appears in the given list. To print the results you can use {FREQ_DIST_DICT}.most_common({N}) , this function prints the {N} most frequent terms inside the dictionary {FREQ_DIST_DICT}. For example: FreqDist([\"hi\",\"bye\",\"ciao\",\"bye\",\"hi\"]) returns {\"hi\": 2, \"bye\":2, \"ciao\": 1} Mark the box to see the solution from nltk.probability import FreqDist def netflix_director_names(): result = [] for show in netflix_data: word_tokens = word_tokenize(show[\"director\"]) result += word_tokens return FreqDist(result) counts = netflix_director_names()","title":"Toward a text analysis of the Netflix shows dataset \u0002wzxhzdk:45\u0003(see also the github repository)\u0002wzxhzdk:46\u0003"},{"location":"chapter/8_lesson/","text":"Data analysis of the Netflix shows - part 3 Date: 11/12/2020 Time: 12:30-14:30 Data visualization Apply a graphic representation on the data: mapping the original data to graphic elements (for example: lines, points, barchart etc). If we want to draw a graphic on top of a dataset, we need to walk through these three steps: What is the nature of our data? What aspects we want to analyse? What are the most suitable graphical elements we can use to present our analysis? Example: Data: a collection of articles. For each article we have the year of its publication and the author/s. Analysis: we want to check how many articles did \"Silvio Peroni\" authored on each different year. Visualization: we can use a barchart. The matplotlib library matplotlib was the first Python data visualization library and it's still widely used for plotting in the Python community. It was designed to closely resemble MATLAB, a popular proprietary programming language. We are especially interested in matplotlib.pyplot , a collection of plotting functions. Each pyplot function makes some change to a figure: e.g., creates a figure, creates a plotting area in a figure, plots some lines in a plotting area, decorates the plot with labels, etc. Note: this is not a builtin library of python so we need to install it using pip install matplotlib import matplotlib.pyplot as plt data = [23,85, 72, 43, 52] labels = ['A', 'B', 'C', 'D', 'E'] # x-Axis ticks and label plt.xticks(range(len(data)), labels) plt.xlabel('Class') # y-Axis label plt.ylabel('Amounts') # chart title plt.title('I am title') # plt a bar plt.bar(range(len(data)), data) plt.show( After running the above script this chart should appear: Data visualizations on the Netflix shows dataset (see also the github repository ) To answer the following exercises we need to use some of the functions we have defined on the previous lessons (part-1, and part-2). a) Draw a graphic using matplotlib which plots the total number of shows (all type of shows) that Netflix added for each different year. b) Draw a graphic using matplotlib which plots the average time (in years) it takes Netflix to add a show on its list after its actual release. Plot this value for each different year. Hint: Take a look at the line charts of matplotlib https://datatofish.com/line-chart-python-matplotlib/ .","title":"Data analysis of the Netflix shows - part 3"},{"location":"chapter/8_lesson/#data-analysis-of-the-netflix-shows-part-3","text":"","title":"Data analysis of the Netflix shows - part 3"},{"location":"chapter/8_lesson/#data-visualization","text":"Apply a graphic representation on the data: mapping the original data to graphic elements (for example: lines, points, barchart etc). If we want to draw a graphic on top of a dataset, we need to walk through these three steps: What is the nature of our data? What aspects we want to analyse? What are the most suitable graphical elements we can use to present our analysis? Example: Data: a collection of articles. For each article we have the year of its publication and the author/s. Analysis: we want to check how many articles did \"Silvio Peroni\" authored on each different year. Visualization: we can use a barchart.","title":"Data visualization"},{"location":"chapter/8_lesson/#the-matplotlib-library","text":"matplotlib was the first Python data visualization library and it's still widely used for plotting in the Python community. It was designed to closely resemble MATLAB, a popular proprietary programming language. We are especially interested in matplotlib.pyplot , a collection of plotting functions. Each pyplot function makes some change to a figure: e.g., creates a figure, creates a plotting area in a figure, plots some lines in a plotting area, decorates the plot with labels, etc. Note: this is not a builtin library of python so we need to install it using pip install matplotlib import matplotlib.pyplot as plt data = [23,85, 72, 43, 52] labels = ['A', 'B', 'C', 'D', 'E'] # x-Axis ticks and label plt.xticks(range(len(data)), labels) plt.xlabel('Class') # y-Axis label plt.ylabel('Amounts') # chart title plt.title('I am title') # plt a bar plt.bar(range(len(data)), data) plt.show( After running the above script this chart should appear:","title":"The matplotlib library"},{"location":"chapter/8_lesson/#data-visualizations-on-the-netflix-shows-dataset-see-also-the-github-repository","text":"To answer the following exercises we need to use some of the functions we have defined on the previous lessons (part-1, and part-2). a) Draw a graphic using matplotlib which plots the total number of shows (all type of shows) that Netflix added for each different year. b) Draw a graphic using matplotlib which plots the average time (in years) it takes Netflix to add a show on its list after its actual release. Plot this value for each different year. Hint: Take a look at the line charts of matplotlib https://datatofish.com/line-chart-python-matplotlib/ .","title":"Data visualizations on the Netflix shows dataset \u0002wzxhzdk:82\u0003(see also the github repository)\u0002wzxhzdk:83\u0003"}]}